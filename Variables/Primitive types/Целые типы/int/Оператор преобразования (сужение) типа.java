long a = 1;
int b = (int) a;
short c = (short) b;
byte d = (byte) c;

long a = 1000000; // a == 1000000
int b = (int) a; // b == 1000000
short c = (short) b; // c == 16960
byte d = (byte) c; // d == 64


// Типы byte, short, char всегда преобразовываются в тип int при взаимодействии между собой. 
// Не зря же тип int считается стандартным целочисленным типом.

// Если умножить byte на short, будет int. Если умножить byte на byte, будет int. Даже если сложить byte и byte, будет int.

byte a = 110;
byte b = 120;
byte c = a * b;   // ошибка
// 110 * 120 будет 13,200, что несколько больше, чем максимальное значение типа byte: 127

byte a = 110;
byte b = 120;
byte c = a + b;   // ошибка
// 110 + 120 будет 230, что тоже несколько больше, чем максимальное значение типа byte: 127

// Поэтому все операции с целыми типами, меньшими чем int, всегда сразу преобразовываются в тип int. 
// И поэтому если вы захотите сохранить результат вычисления в переменную типа, меньше чем int, 
// вам всегда нужно будет явно указывать операцию приведения типа.
byte a = 110;
byte b = 120;
byte c = (byte) (a * b); // выражение byte * byte будет иметь тип int

byte a = 110;
byte b = 120;
byte c = (byte) (a + b); // выражение byte + byte будет иметь тип int

byte a = 1;
byte b = (byte) (a + 1); // выражение byte + int будет иметь тип int
// единица – это литерал типа int.


// Операция приведения типа имеет довольно высокий приоритет.
// Поэтому если в выражении есть, допустим, сложение и операция приведения типа, она будет выполнена до сложения.

byte a = 1;
byte b = 2;
byte c = (byte) a * b; // Оператор приведения типа будет применен только к переменной a, которая и так имеет тип byte. Код не скомпилируется.

byte a = 1;
byte b = 2;
byte c = (byte) (a * b);
// Если вы хотите преобразовать к определенному типу все выражение, а не только один его элемент, 
// то оборачивайте все выражение в круглые скобки и перед ними ставьте оператор приведения типа.
